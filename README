Magic Rescue
------------

Magic Rescue scans a block device for file types it knows how to recover and
calls an external program to extract them. It looks at "magic bytes" in file
contents, so it can be used both as an undelete utility and for recovering a
corrupted drive or partition. As long as the file data is there, it will find
it.

It works on any file system, but on very fragmented file systems it can only
recover the first chunk of each file. Practical experience (this program was
not written for fun) shows, however, that chunks of 30-50MB are not uncommon.

Find the latest version at http://jbj.rapanden.dk/magicrescue/

Building
--------

Just type "make". You will need a CPU/compiler that can do 64-bit arithmetic if
you want to recover from devices over 2GB.
Don't install it, just run it from the source directory.

Using
-----

Say you have destroyed the file system on /dev/hdb1 and you want to extract
all the jpeg files you lost.

Make sure DMA and other optimizations are enabled on your disk, or it will take
hours.
$ hdparm -d 1 -c 1 -u 1 /dev/hdb

Choose your output directory, somewhere with lots of disk space.
$ mkdir ~/output

Look in the recipes/ directory of the source for the recipes you want. Magic
Rescue somes with recipes for some common file types, and you can make your own
too (see the next section).
Then invoke magicrescue
$ ./magicrescue -r recipes/jpeg-jfif -r recipes/jpeg-exif -d ~/output /dev/hdb1

It will scan through your entire hard disk, so it may take a while. When it has
finished you will probably find thousands of .jpg files in ~/output, including
things you never knew was in your browser cache. Sorting through all those
files can be a huge task, so you may want to write software or scripts to do
it.

Extending
---------

A recipe file is a relatively simple file of 3-5 lines of text. It describes
how to recognise the beginning of the file and what to do when a file is
recognised. For example, all PNG images start with the byte 0x89 followed by
the letters PNG, followed by the bytes 0D 0A 1A 0A. Look at recipes/png in the
source distribution to follow this example.

Matching magic data is done with a "match operation" that looks like this:
<offset> <operation> <parameter>
where <offset> is a decimal integer saying how many bytes from the beginning of
the file this data is located, <operation> refers to a built-in match operation
in magicrescue, and <parameter> is specific to that operation.

The first non-comment line of a recipe must be of the form
<offset> char <character>
The "char" operation matches a single character. In the PNG example, we first
look for the character 0x89 (written as \x89). When that character is found,
magicrescue proceeds to the next match operation.

The "string" operation matches a string of any length. In the PNG example this
is four bytes.
The "int32" operation matches 4 bytes ANDed with a bit mask. To match all four
bytes, use the bit mask ffffffff. If you have no idea what a bit mask is, just
use the "string" operation instead.

To learn these patterns, look at files of the desired type in a hex editor,
search through the resource files for the "file" utility
(http://freshmeat.net/projects/file) and/or search google for a reference on
the format.

If all the operations match, we have found the start of the file. Finding the
end of the file is a much harder problem, and therefore it is delegated to an
external command, which is named by the "command" directive. This command
receives the block device's file descriptor on stdin and must write to the file
given to it in the $0 variable. Apart from that, the command can do anything it
wants to try and extract the file.
For some file types (such as jpeg), a tool already exists that can do this.
However, many programs misbehave when told to read from the middle of a huge
block device. Some seek to byte 0 before reading (can be fixed by prefixing
cat|), and some refuse to work on a file they can't seek in. Others try to read
the whole file into memory before doing anything, which will of course fail on
a muti-gigabyte block device. And some fail completely to parse a partially
corrupted file.
This means that you may have to write your own tool or wrap an existing program
in some scripts that make it behave better. For example, this could be to
extract the first 10MB into a temporary file and let the program work on that.
Or perhaps you can use commands/safecat if the file may be very large.

For a full reference on creating recipes, read README.recipes
